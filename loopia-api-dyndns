#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Dynamically updates the IPv4/IPv6 DNS records for domains registered with Loopia.
https://joelpurra.com/projects/loopia-api-dyndns/

Based on Loopia API's official sample script.
https://support.loopia.se/wiki/uppdatera-dynamisk-ip-adress-med-loopiaapi/
"""

import ipaddress
import os
import re
import sys
import urllib.request
import xmlrpc.client


class Config:
    username = os.environ["LOOPIA_API_USERNAME"]
    password = os.environ["LOOPIA_API_PASSWORD"]
    domain = os.environ["LOOPIA_DOMAIN"]
    subdomain = os.environ["LOOPIA_SUBDOMAIN"]

    fqdn = domain if subdomain == "@" else subdomain + "." + domain

    check_ipv4_url = "https://api-ipv4.ip.sb/ip"
    check_ipv6_url = "https://api-ipv6.ip.sb/ip"
    loopia_api_xml_rpc_url = "https://api.loopia.se/RPCSERV"


def print_error(msg):
    print(msg, file=sys.stderr)


def api_error():
    print_error("Unknown API Error.")
    quit(1)


def get_string_value_from_url(url, max=None):
    try:
        return urllib.request.urlopen(url).read(max).decode("utf-8").strip()
    except:
        print_error(
            "Could not get string from url: {url}".format(
                url=url,
            )
        )
        quit(5)


def get_public_ipv4():
    ipv4str_from_url = get_string_value_from_url(Config.check_ipv4_url, 15)
    try:
        return str(ipaddress.IPv4Address(ipv4str_from_url))
    except:
        print_error(
            "Could not parse IPv4 address: {ipv4str}".format(
                ipv4str_from_url=ipv4str_from_url,
            )
        )
        quit(7)


def get_public_ipv6():
    ipv6str_from_url = get_string_value_from_url(Config.check_ipv6_url, 45)
    try:
        return str(ipaddress.IPv6Address(ipv6str_from_url))
    except:
        print_error(
            "Could not parse IPv6 address: {ipv6str}".format(
                ipv6str_from_url=ipv6str_from_url,
            )
        )
        quit(8)


def get_records(recordType):
    try:
        zone_records = client.getZoneRecords(
            Config.username,
            Config.password,
            Config.domain,
            Config.subdomain
        )

        # Remove irrelevant records and return.
        return [d for d in zone_records if d["type"] == recordType]
    except:
        if "AUTH_ERROR" in zone_records:
            print_error("API credentials are incorrect.")
            quit(2)

        api_error()


def update_record(value, record):
    # Does the record need updating?
    if record["rdata"] != value:
        # Yes, it does. Update it!
        # Setting record_id updates an existing record.
        new_record = {
            "priority": record["priority"],
            "rdata": value,
            "record_id": record["record_id"],
            "ttl": record["ttl"],
            "type": record["type"]
        }

        try:
            status = client.updateZoneRecord(
                Config.username,
                Config.password,
                Config.domain,
                Config.subdomain,
                new_record
            )

            print(
                "{fqdn} ({recordType}, {value}): {status}".format(
                    recordType=record["type"],
                    fqdn=Config.fqdn,
                    status=status,
                    value=value
                )
            )

        except:
            api_error()

    else:
        # Record does not need updating.
        print(
            "{fqdn} ({recordType}, {value}): No change".format(
                recordType=record["type"],
                fqdn=Config.fqdn,
                value=value
            )
        )


def check_and_update_record(recordType, value):
    """Fetch a single record and update it"""
    records = get_records(recordType)

    if len(records) != 1:
        print_error(
            "Require exactly one {recordType} record for {fqdn}, but found {recordCount}.".format(
                fqdn=Config.fqdn,
                recordType=recordType,
                recordCount=len(records)
            )
        )
        quit(4)

    update_record(value, records[0])


if __name__ == "__main__":
    # Build XML RPC client
    client = xmlrpc.client.ServerProxy(
        uri=Config.loopia_api_xml_rpc_url,
        encoding="utf-8"
    )

    # Get current A records and public IPv4 address
    public_ipv4 = get_public_ipv4()
    check_and_update_record("A", public_ipv4)

    # Get current AAAA records and public IPv6 address
    public_ipv6 = get_public_ipv6()
    check_and_update_record("AAAA", public_ipv6)
