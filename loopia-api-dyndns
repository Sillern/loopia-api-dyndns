#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
########### HOW TO USE THIS FILE ###########

A few rows down are several variables that you have to change.
Remember to NOT use your Customer Zone credentials, but your LoopiaAPI credentials.

If you don't have an API user yet you can create one in the Customer Zone.
For reasons of security you shouldn't add more permissions than necessary.

The user requires the following permissions for this script to function:
* getZoneRecords    - To find out which record to update
* updateZoneRecord  - To actually update the zone record

The following permissions are optional but recommended:
* removeZoneRecord  - If the zone has several A-records, this is necessary to remove all excess records.
* addZoneRecord     - Necessary if the zone doesn't have any A-record at all.

This script requires Python 3.0 or later.
Any versions earlier than Python 3.0 WILL fail.

On Linux, Mac OS and other Unix based systems you can use "cron"
to schedule this script to make sure your IP address is updated automatically.
On Windows you can use the "Task Scheduler".

https://support.loopia.se/wiki/uppdatera-dynamisk-ip-adress-med-loopiaapi/
https://www.loopia.se/api/

Please contact support@loopia.se if you have any questions.
"""

import os
import re
import urllib.request
import xmlrpc.client


class Config:
    ########## ENVIRONMENT VARIABLE CONFIGURATION ##########
    # Your LoopiaAPI user credentials
    # Remember, these are NOT the same as your credentials for the Loopia Customer Zone.
    username = os.environ['LOOPIA_API_USERNAME']
    password = os.environ['LOOPIA_API_PASSWORD']

    # Which domain name do you wish to update?
    # Omit any subdomains here (i.e only write "mindoman.se", not "www.mindoman.se").
    domain = os.environ['LOOPIA_DOMAIN']

    # Which subdomain do you wish to update? Use "@" if you wish to update the root domain.
    # Hint!
    # If you wish to change the IP address for the main subdomains ("@", "www" and "*")
    # you only need to keep "@" updated.
    # Point the other subdomains to the main domain with CNAME records.
    subdomain = os.environ['LOOPIA_SUBDOMAIN']

    # Time To Live value. You don't actually have to change this at all unless
    # you have a very specific reason for wanting a different value.
    # This value is only used when creating new records, not when modifying existing.
    ttl = os.environ.get('LOOPIA_TTL', '300')

    ######### END ENVIRONMENT VARIABLE CONFIGURATION #########

    checkIpv4Url = 'https://api-ipv4.ip.sb/ip'
    checkIpv6Url = 'https://api-ipv6.ip.sb/ip'
    apiXmlRpcUrl = 'https://api.loopia.se/RPCSERV'


def api_error():
    """Print a warning message because an error has occured"""
    # Please check your internet connection and https://www.driftbloggen.se/ Contact support@loopia.se if the problem persists.
    print('Unknown API Error.')
    quit(1)


def del_excess(zone_records):
    """Remove all A records except the first one"""
    num = 0
    for record in zone_records:
        client.removeZoneRecord(
            Config.username,
            Config.password,
            Config.domain,
            Config.subdomain,
            record['record_id']
        )
        num = num + 1

    print('Deleted {} unnecessary record(s)'.format(str(num)))


def get_public_ipv4():
    """Get public IPv4 adress"""
    return urllib.request.urlopen(Config.checkIpv4Url).read()


def get_public_ipv6():
    """Get public IPv6 adress"""
    return urllib.request.urlopen(Config.checkIpv6Url).read()


def get_records(recordType):
    """Get current zone records"""
    try:
        zone_records = client.getZoneRecords(
            Config.username,
            Config.password,
            Config.domain,
            Config.subdomain
        )
        # Remove irrelevant records and return
        return [d for d in zone_records if d['type'] == recordType]
    except:
        # Quit if unable to authorize
        if 'AUTH_ERROR' in zone_records:
            print('Your user information seems to be incorrect. Please edit this file and check your username and password.')
            quit(2)

        # Quit if API returns unknown error
        if 'UNKNOWN_ERROR' in zone_records:
            print('API returned "UNKNOWN ERROR". This could mean that the requested (sub)domain does not exist in this account.')
            quit(3)

        # Can't connect to the API for other reasons
        api_error()


def add_record(recordType, value):
    """Add a new record if we don't have any"""
    new_record = {
        'priority': '',
        'rdata': value,
        'type': recordType,
        'ttl': Config.ttl
    }

    status = client.addZoneRecord(
        Config.username,
        Config.password,
        Config.domain,
        Config.subdomain,
        new_record
    )

    if Config.subdomain == '@':
        print(
            '{domain}: {status}. Added new record.'.format(
                domain=Config.domain,
                status=status
            )
        )
    else:
        print(
            '{subdomain}.{domain}: {status}. Added new record.'.format(
                subdomain=Config.subdomain,
                domain=Config.domain,
                status=status
            )
        )


def update_record(value, record):
    """Update current record"""
    # Does the record need updating?
    if record['rdata'] != value:
        # Yes it does. Update it!
        new_record = {
            'priority': record['priority'],
            'record_id': record['record_id'],
            'rdata': value,
            'type': record['type'],
            'ttl': record['ttl']
        }

        try:
            status = client.updateZoneRecord(
                Config.username,
                Config.password,
                Config.domain,
                Config.subdomain,
                new_record
            )

            if Config.subdomain == '@':
                print(
                    '{domain}: {status}'.format(
                        domain=Config.domain,
                        status=status
                    )
                )
            else:
                print(
                    '{subdomain}.{domain}: {status}'.format(
                        subdomain=Config.subdomain,
                        domain=Config.domain,
                        status=status
                    )
                )

        except:
            api_error()

    else:
        # Record does not need updating
        if Config.subdomain == '@':
            print(
                '{domain}: No change'.format(
                    domain=Config.domain
                )
            )
        else:
            print(
                '{subdomain}.{domain}: No change'.format(
                    subdomain=Config.subdomain,
                    domain=Config.domain
                )
            )


def addorUpdateRecord(recordType, value):
    """Add a record, potentially updating an existing record, and remove all excess records of the same type"""
    records = get_records(recordType)

    # Do we currently have a record? If not, create one!
    if len(records) == 0:
        add_record(recordType, value)

    else:
        # Remove all excess records
        if len(records) > 1:
            del_excess(records[1:])

        # Now let's update the record!
        update_record(value, records[0])


if __name__ == '__main__':
    # Build XML RPC client
    client = xmlrpc.client.ServerProxy(
        uri=Config.apiXmlRpcUrl,
        encoding='utf-8'
    )

    # Get current A records and public IP address
    publicIpv4 = get_public_ipv4()
    addorUpdateRecord('A', publicIpv4)

    # Get current AAAA records and public IP address
    publicIpv6 = get_public_ipv6()
    addorUpdateRecord('AAAA', publicIpv6)
